## 원형 큐
 - front = rear = 0 ( 초기 공백 상태 )
 - front와 rear가 마지막 인덱스 n-1에서 0으로 이동 by 논리적 순환
 - 나머지 연산자 mod 이용
 - front 변수 : 구조 상 공백과 포화 상태 구분이 어려움.
                front가 있는 자리는 사용하지 않고 항상 빈자리
                공백 : front == rear  /  포화 : (n + front - rear) % n == 1 ? (n은 배열 크기)
                            (front == (rear+1)%n을 해도 된다캄)
 - 구현 방법 : 크기 n인 1차원 배열을 front와 rear을 0으로 초기화해서 초기 공백 큐 생성
 - isEmpty() : front = rear  /  isFull() : (rear + 1) mod n = front
 - ...
 -


## 우선순위 큐
 - FIFO가 아니라 우선순위가 높은 순서대로 OUT
 - 시뮬레이션, 네트워크 트래픽 제어, 운영체제 태스크 스케쥴링
 - 배열, 연결리스트 이용
 - 늦게 들어오더라도 우선 순위에 따라 조정되어 정렬
    위치 찾으며 들어가기 O(N) 끼어 어쩌구 저쩌구 O(N)

### 삽입 정렬
 - 도서관 사서의 책 정렬과 동일함
 - 부분집합 S : 정렬된 앞부분 원소들  /  U : 아직 정렬되지 않은 나머지
 - U에서 하나씪 꺼내서 S에 하나씩 비교하면서 삽입
 - U가 공집합 되면 정렬 완성
 - O(n^2)
 - 앞에서부터 보면 S의 모든 데이터에 접근하여 밀어낼 데이터 파악해야함
    뒤에서부터는 굳이 확인 안해도 되서 위치만 확인하면 끝
 - 이미 정렬된 데이터가 많고, 새로 드러온 데이터가 많을 때, 추가되는 빈도가 많을 때