## 스택
 - 스택 자료는 선형 구조 : 자료 간 1:1의 관계 (배열, 리스트)
                (비선형 : 자료 간의 관계가 1:N ex.트리)
 - 마지막 삽입된 원소의 위치 : top
 - 배열과 리스트는 스택의 상위호환. 그러나... 추상화라는 메리트?
    마지막 원소가 제일 중요하다는 점! 캡슐화로 마지막 원소 외에는 접근 불가!
 - push, pop, isEmpty, peek(탑의 원소 확인,반환)
 - stack[++top] = item; : 0->쭉 쌓여짐
 - return stack[top--]; : 탑이 서서히 내려오면서 숫자 감소
                        이 때 탑의 인덱스는 따로 지워줄 필요가 없다?(확인요망)
 - 1차원 배열 사용 : 구현이 용이  but 스택 크기 변경 힘듬.

### 재귀호출
 - Base case : 재귀호출에서 빠져 나가기 위한 조건 (기저조건) 
 - 스택 오버플로우 : 스택 메모리를 넘어서 호출하면...
 - 피보나치 수열 : F0 = 0, F1 = 1, Fi = F(i-1) + F(i-2) for i>=2
        * 엄청난 중복호출 존재 (ex. Fibo(7)을 구할 때 Fibo(2) 레벨)
        * 효율적인 코드구성이지만 2^n이라는 엄청난 시간복잡도 주의

## 큐 (Queue)
 - 머리(Front or head)와 꼬리(Rear or tail)로 구성
 - en : de ; Queue = 삽입 : 삭제&반환
 - Qpeek : 스택과 동일 기능  /  createQueue : 생성 및 초기화 (공백의 큐)
 - front=rear=-1로 초기화, front : 제일 앞 데이터의 한칸 앞, rear : 마지막 데이터의 인덱스 지칭
                        마지막으로 삭제된 인덱스 & 저장된 마지막 원소의 인덱스라 해도됨
    따라서 rear-front = size(데이터 개수)
    포화 상태일 땐 rear = n-1
 - 다 삭제 후 넣으면 front 다음 위치로 오게 됨
 - 배열의 크기 : n -> n개 넣을수 있다 X 최대 n번 넣을 수 있다 O

### 선형 큐의 문제점
 - 잘못된 포화상태 인식 -> 해결법? -> 남은 걸 앞으로 다 당기면 O(N)의 시간복잡도
   1. 배열 대신 연결리스트 쓰면 O(1)으로 해결 가능
   2. 1차원 배열을 쓰되 원형 큐를 이룬다고 가정하고 사용(끝에서 시작으로)
        모듈러 연산을 통해 i+1 이슈 해결 : i = (i+1)% => N으로 해결?
        그러나... 포화 상태와 공백 상태의 구분이 어렵다라는 이슈? -> 원형큐 시간에 논의

### 큐의 화룡
 - 버퍼 : 데이터 전송하는 동안 일시적으로 데이터 보관하는 메모리 영역

## 원형 큐
 - front = rear = 0 ( 초기 공백 상태 )
 - front와 rear가 마지막 인덱스 n-1에서 0으로 이동 by 논리적 순환
 - 나머지 연산자 mod 이용
 - front 변수 : 구조 상 공백과 포화 상태 구분이 어려움.
                front가 있는 자리는 사용하지 않고 항상 빈자리
                공백 : front == rear  /  포화 : (n + front - rear) % n == 1 ? (n은 배열 크기)
                            (front == (rear+1)%n을 해도 된다캄)
 - 구현 방법 : 크기 n인 1차원 배열을 front와 rear을 0으로 초기화해서 초기 공백 큐 생성
 - isEmpty() : front = rear  /  isFull() : (rear + 1) mod n = front

## 우선순위 큐
 - FIFO가 아니라 우선순위가 높은 순서대로 OUT
 - 시뮬레이션, 네트워크 트래픽 제어, 운영체제 태스크 스케쥴링
 - 배열, 연결리스트 이용
 - 늦게 들어오더라도 우선 순위에 따라 조정되어 정렬
    위치 찾으며 들어가기 O(N) 끼어 어쩌구 저쩌구 O(N)

### 삽입 정렬
 - 도서관 사서의 책 정렬과 동일함
 - 부분집합 S : 정렬된 앞부분 원소들  /  U : 아직 정렬되지 않은 나머지
 - U에서 하나씪 꺼내서 S에 하나씩 비교하면서 삽입
 - U가 공집합 되면 정렬 완성
 - O(n^2)
 - 앞에서부터 보면 S의 모든 데이터에 접근하여 밀어낼 데이터 파악해야함
    뒤에서부터는 굳이 확인 안해도 되서 위치만 확인하면 끝
 - 이미 정렬된 데이터가 많고, 새로 드러온 데이터가 많을 때, 추가되는 빈도가 많을 때

 ## 연결 리스트 (LinkedList)
 - 선형 자료구조 => 따라서 스택과 큐 구현 가능(동적 크기)
 - 자료의 논리적 순서 != 메모리 상의 물리적인 순서, 각자 위치에서 주소 연결
 - 인덱스가 중간에 사라지면 남은 인덱스끼리 재연결(물리적인 순서를 위한 작업 불필요)
 - 동적, 따라서 메모리의 효율적 사용
 - 조회 선행 필요(O(N))-Node배열화로 효율화 가능하지만 나중에... , 삽입 삭제(O(1))

### 노드
 - 자료 단위 for 하나의 원소에 대한 데이터
 - 멤버 변수로는 데이터, 링크

### 헤드
 - 리스트의 시작 위치의 노드(보통 데이터가 필요없기에 링크만 존재)

## 단순 연결 리스트 (Singly LinkedList, 단방향 연결 리스트, Single LinkedList)
 - 연결 구조 : one by one (하나의 링크->다음 노드)
 - NULL : 리스트의 마지막 노드(링크)
 - 구현 방법
    1. Head가 첫번째 데이터를 가지는 노드

    2. Head가 빈 데이터를 가진 더미노드 
        pros. 구현이 좀 더 쉬움(다 지워졌을 때 헤드가 null 아니기 때문)
        cons. 메모리 사용량이 미세하게 올라감(일반적으로 큰 의미 없음)

### 삽입 방식
 1. 메모리를 할당하여 새로운 노드 "new" 생성
 2. new의 데이터 필드에 'B' 저장
 3. B의 링크 -> C
 4. A의 링크 -> B

### 삭제 방식
 1. currentnode = 'B' 노드 -> 'A'노드로 변경 (삭제할 노드 앞의 노드)
 2. curr.link = curr.link.link = C (B 거르고 한칸 건너 뛰게 만듬)
 3. B에 더이상 접근 못하므로 garbage Collector가 제거함

 -  첫번째 노드 삽입 알고리즘 : 더미노드 안만드는 알고리즘

## 이중 연결 리스트 (양방향 연결 리스트)
 - 2개의 링크 필드, 1개의 데이터 필드
 - 양쪽 방향으로 순회하도록 노드 연결
 - tail node 생성-> prev.가 마지막 노드를 가리키도록...!

### 삽입 방식
 1. A노드 찾기 -> curr
 2. new 노드 연결
 3. 새 노드의 next = curr.link , 새 노드의 prev = curr
 4. curr.link.prev = newNode, curr.link = newNode (그 외에 다양한 방법이 있음)

    ex. rmNode가 삭제해야할 때,
        rmNode.prev.next = rmNode.next
        rmNode.next.prev = rmNode.prev

## 배열을 이용한 우선순위 큐
 - 배열이므로 삽입이나 삭제 연산에서 재연산이 발생


### 배열 vs 연결리스트
 * 삽입&삭제 : O(N) vs O(1)
 * 조회 : O(1) vs O(N)