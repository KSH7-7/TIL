## 분할정복
 - 분할 - 정복 - 결합 (병합정렬은 결합 必 그러나 퀵정렬은 X)
 - C^n 구하는 문제... 반복문을 쓰면 O(N)이지만 분할정복 쓰면 O(logN)

## 이진검색
 - 병뚜껑 숫자 맞추기류...
 - 정렬된 배열!이라는 조건...
 - 중앙 값 찾기 - 목표 값과 중앙 값 비교 - 탐색 범위가 한 개의 원소가 될 때까지 반복 수행
 - 중간 값 세팅할때 아---주 간혹 조심(left: 11억, right: 11억 -> 오버플로우)
 - 삽입 삭제가 자주 일어나면 비효율을 향해 달려감
 - 크기가 작으면 이점 딱히 없어짐
 - 심화
    * java.util.Arrays.binarySearch 메서드 공부
    * BST (이진검색트리) - 아주 나중에 공부 권함
    * 이진검색응용(Lower Bound, Upper Bound)

## 병합정렬
 - 분할 정복을 활용한 정렬 알고리즘
 - 분할 -> 재귀적 정렬 -> 병합
 - O(NlogN)
 - 정렬을 위한 추가공간 필요
 - 단계
    1. 분할
    2. 정복
    3. 병합

## 퀵 정렬
 - 추가 공간이 필요없음...!
 - O(NlogN)이지만 최악의 경우 O(N^2)
 - 단계 ( Pivot 결정 )
    - Hoare 파티션
    1. 피벗 선택(F -> L -> m -> Random -> FLm의 중앙값)
    2.
    3.
    - Lomuto 파티션
