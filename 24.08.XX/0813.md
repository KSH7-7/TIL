## 연결 리스트 (LinkedList)
 - 선형 자료구조 => 따라서 스택과 큐 구현 가능(동적 크기)
 - 자료의 논리적 순서 != 메모리 상의 물리적인 순서, 각자 위치에서 주소 연결
 - 인덱스가 중간에 사라지면 남은 인덱스끼리 재연결(물리적인 순서를 위한 작업 불필요)
 - 동적, 따라서 메모리의 효율적 사용
 - 조회 선행 필요(O(N))-Node배열화로 효율화 가능하지만 나중에... , 삽입 삭제(O(1))

### 노드
 - 자료 단위 for 하나의 원소에 대한 데이터
 - 멤버 변수로는 데이터, 링크

### 헤드
 - 리스트의 시작 위치의 노드(보통 데이터가 필요없기에 링크만 존재)

## 단순 연결 리스트 (Singly LinkedList, 단방향 연결 리스트, Single LinkedList)
 - 연결 구조 : one by one (하나의 링크->다음 노드)
 - NULL : 리스트의 마지막 노드(링크)
 - 구현 방법
    1. Head가 첫번째 데이터를 가지는 노드

    2. Head가 빈 데이터를 가진 더미노드 
        pros. 구현이 좀 더 쉬움(다 지워졌을 때 헤드가 null 아니기 때문)
        cons. 메모리 사용량이 미세하게 올라감(일반적으로 큰 의미 없음)

### 삽입 방식
 1. 메모리를 할당하여 새로운 노드 "new" 생성
 2. new의 데이터 필드에 'B' 저장
 3. B의 링크가 먼저 C에 연결
 4. A의 링크를 B에 연결

### 삭제 방식
 1. currentnode = 'B' 노드 -> 'A'노드로 변경 (삭제할 노드 앞의 노드)
 2. curr.link = curr.link.link = C (B 거르고 한칸 건너 뛰게 만듬)
 3. B에 더이상 접근 못하므로 garbage Collector가 제거함

 -  첫번째 노드 삽입 알고리즘 : 더미노드 안만드는 알고리즘

## 이중 연결 리스트 (양방향 연결 리스트)
 - 2개의 링크 필드, 1개의 데이터 필드
 - 양쪽 방향으로 순회하도록 노드 연결
 - tail node 생성-> prev.가 마지막 노드를 가리키도록...!

### 삽입 방식
 1. A노드 찾기 -> curr
 2. new 노드 연결
 3. 새 노드의 next = curr.link , 새 노드의 prev = curr
 4. curr.link.prev = newNode, curr.link = newNode (그 외에 다양한 방법이 있음)

    ex. rmNode가 삭제해야할 때,
        rmNode.prev.next = rmNode.next
        rmNode.next.prev = rmNode.prev

## 배열을 이용한 우선순위 큐
 - 배열이므로 삽입이나 삭제 연산에서 재연산이 발생


### 배열 vs 연결리스트
 * 삽입&삭제 : O(N) vs O(1)
 * 조회 : O(1) vs O(N)