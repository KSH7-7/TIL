## 동적 계획법
### 피보나치 수열
 - 토끼 케이스 : 첫째 달과 둘째 달 차이 = 증식 가능 여부
    => 새로 태어나는 케이스는 아직 증식 불가능 상태(성체와 유체 차이)
    => 첫째와 둘째달은 알고 있어야 전개 가능

### 메모이제이션
 - 이전 계산값을 메모리에 저장해서 재호출 방지-> 실행속도 증가
    ex. C^8 = C^4 * C^4
 - 피보나치를 O(2^n)에서 O(n) 레벨로 떨굼
 - 하향식 접근법
 - 그러나, 추가 메모리 공간 필요, 시스템 호출 스택 사용으로 인한 오버플로 가능성
    => 동적 계획 알고리즘의 필요성

### 동적 계획 알고리즘
 - 최적화 문제 해결하는 알고리즘 like 그리디 알고리즘
 - 특정 최적해 X, 어떤 최적해 O
 - 작은 부분 해 -> 큰 부분 해결
 - 필수 요건 : 중복 부분문제 구조 & 최적 부분문제 구조
#### 중복 부분문제 구조
 - table을 통해 꺼내옴..!

#### 최적 부분문제 구조
 - 문제가 최적화의 원칙을 만족해야 함 ( 어떤 문제의 해가 최적 -> 구성하는 작은 문제의 해 역시 최적 )
    * 적용되지 않는 경우: 최장경로 문제, ...

### 분할 정복 vs 동적 계획법
 - 분.정  
    1. 연관 없는 부분 문제로 분할
    2. 부분문제를 재귀적 해결 및 결합 (병합정렬 / 퀵정렬)
    3. 하향식 방법 접근
   
 - DP
    1. 연관 없으면 적용 불가( 부분 문제들은 더 작은 부분 문제를 공유 )
    2. 모든 부분 문제를 한번만 계산 & 결과 저장 & 재사용
    3. 상향식 방법 접근
    4. 부분 문제들 사이에 의존적 관계... -> 함축적 순서

### 3단계 DP 적용 접근 방법
 1. 최적해 구조의 특성 파악 : 부분 문제로 분할
 2. 최적해 값을 재귀적으로 정의 : 문제의 최적해 값 정의
 3. 상향식 방법으로 최적해 값 계산 : 가장 작은 부분부터 해를 구해 table 저장
                                table에 저장된 것을 통해 상위 부분 해결

#### 알고리즘 분석
 - 수행속도가 더 빠름
    1. 재귀 알고리즘과 달리 중복 계산 X
    2. 반복문이기에 함수 호출 발생 X
    3. dp[0]부터 dp[n]까지 한번씩 계산

#### 동전 거스름 문제
 - 배수 관계가 없으면 큰거부터 하면 안됨
 - 그리디의 한계 : 눈에 보이는게 답은 아니다
 - DP : 1원에 대한 최적해 -> 2원.. -> ... -> j원
 - 부분 문제 정의
    C[i][j] = Di라는 동전으로 j원 거슬러줄 때 최적
 - 부분 문제에서 최적으로 거슬러 주지 않으면 전체 개수도 최적 X : 최적화의 원리
 - C[i][j] = min( C[i][j-Di] + 1, C[i-1][j] ) -> O(i * j)

#### 배낭 문제 (0-1 Knapsack 문제)
 - n개의 물건, 각 물건 i의 무게 Wi와 가치 Vi, 배낭의 용량 W일 때, 최대 가치
 - K[i, W] ={ 0    (if i = 0 or W = 0)
              K[i - 1, W]   (if Wi > W)
              max(Vi + K[i - 1, W - Wi], K[i - 1, W])   (if i > 0 & Wi <= W)
            }
            